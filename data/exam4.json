{
  "title": "Certification Java 21 - Héritage, Encapsulation, Polymorphisme & Interfaces",
  "duration": 25,
  "questions": [
    {
      "topic": "Héritage",
      "question": "Que va afficher ce code ?<br><pre><code class='language-java'>class Parent {\n    void method() { System.out.print(\"Parent\"); }\n}\nclass Child extends Parent {\n    void method() { System.out.print(\"Child\"); }\n}\nParent obj = new Child();\nobj.method();</code></pre>",
      "options": [
        "<code>Parent</code>",
        "<code>Child</code>",
        "<code>Compilation error</code>",
        "<code>Runtime error</code>"
      ],
      "answer": 1,
      "difficulty": "beginner",
      "explanation": "La liaison dynamique fait que la méthode de la classe Child est appelée, même si la référence est de type Parent."
    },
    {
      "topic": "Encapsulation",
      "question": "Quel est le résultat de ce code ?<br><pre><code class='language-java'>class Test {\n    private int value = 10;\n    public int getValue() { return value; }\n    public void setValue(int v) { this.value = v; }\n}\nTest t = new Test();\nt.setValue(20);\nSystem.out.println(t.getValue());</code></pre>",
      "options": [
        "<code>10</code>",
        "<code>20</code>",
        "<code>Compilation error</code>",
        "<code>0</code>"
      ],
      "answer": 1,
      "difficulty": "beginner",
      "explanation": "La valeur est correctement modifiée via le setter et récupérée via le getter. L'encapsulation fonctionne normalement."
    },
    {
      "topic": "Polymorphisme",
      "question": "Quelle méthode sera appelée ?<br><pre><code class='language-java'>class Calculator {\n    public int add(int a, int b) { return a + b; }\n    public double add(double a, double b) { return a + b; }\n    public int add(int a, int b, int c) { return a + b + c; }\n}\nCalculator calc = new Calculator();\nint result = calc.add(5, 3);</code></pre>",
      "options": [
        "La méthode <code>add(double, double)</code>",
        "La méthode <code>add(int, int)</code>",
        "La méthode <code>add(int, int, int)</code>",
        "<code>Compilation error</code>"
      ],
      "answer": 1,
      "difficulty": "intermediate",
      "explanation": "La surcharge de méthodes choisit la méthode avec la signature exacte correspondante : add(int, int)."
    },
    {
      "topic": "Interfaces",
      "question": "Que va afficher ce code ?<br><pre><code class='language-java'>interface Drawable {\n    default void draw() { System.out.print(\"Interface\"); }\n}\nclass Circle implements Drawable {\n    public void draw() { System.out.print(\"Circle\"); }\n}\nDrawable d = new Circle();\nd.draw();</code></pre>",
      "options": [
        "<code>Interface</code>",
        "<code>Circle</code>",
        "<code>Compilation error</code>",
        "<code>InterfaceCircle</code>"
      ],
      "answer": 1,
      "difficulty": "intermediate",
      "explanation": "La méthode redéfinie dans Circle remplace la méthode default de l'interface."
    },
    {
      "topic": "Héritage",
      "question": "Quel est le résultat de ce code ?<br><pre><code class='language-java'>class Animal {\n    Animal() { System.out.print(\"Animal\"); }\n}\nclass Dog extends Animal {\n    Dog() { System.out.print(\"Dog\"); }\n}\nDog d = new Dog();</code></pre>",
      "options": [
        "<code>Dog</code>",
        "<code>Animal</code>",
        "<code>AnimalDog</code>",
        "<code>DogAnimal</code>"
      ],
      "answer": 2,
      "difficulty": "intermediate",
      "explanation": "Le constructeur de la classe parent est toujours appelé en premier, puis celui de la classe enfant."
    },
    {
      "topic": "Encapsulation",
      "question": "Que se passe-t-il avec ce code ?<br><pre><code class='language-java'>class BankAccount {\n    private double balance = 1000;\n}\nclass Main {\n    public static void main(String[] args) {\n        BankAccount account = new BankAccount();\n        System.out.println(account.balance);\n    }\n}</code></pre>",
      "options": [
        "<code>1000.0</code>",
        "<code>0.0</code>",
        "<code>Compilation error</code>",
        "<code>Runtime error</code>"
      ],
      "answer": 2,
      "difficulty": "beginner",
      "explanation": "L'attribut balance est private et ne peut pas être accédé directement depuis l'extérieur de la classe."
    },
    {
      "topic": "Polymorphisme",
      "question": "Que va afficher ce code ?<br><pre><code class='language-java'>class Shape {\n    void area() { System.out.print(\"Shape\"); }\n}\nclass Rectangle extends Shape {\n    void area() { System.out.print(\"Rectangle\"); }\n}\nclass Square extends Rectangle {\n    void area() { System.out.print(\"Square\"); }\n}\nShape s = new Square();\ns.area();</code></pre>",
      "options": [
        "<code>Shape</code>",
        "<code>Rectangle</code>",
        "<code>Square</code>",
        "<code>Compilation error</code>"
      ],
      "answer": 2,
      "difficulty": "intermediate",
      "explanation": "La liaison dynamique appelle la méthode de la classe la plus spécifique, ici Square."
    },
    {
      "topic": "Interfaces",
      "question": "Quel est le résultat de ce code ?<br><pre><code class='language-java'>interface A {\n    default void method() { System.out.print(\"A\"); }\n}\ninterface B {\n    default void method() { System.out.print(\"B\"); }\n}\nclass C implements A, B {\n    // Aucune redéfinition de method()\n}\nC c = new C();</code></pre>",
      "options": [
        "<code>A</code>",
        "<code>B</code>",
        "<code>AB</code>",
        "<code>Compilation error</code>"
      ],
      "answer": 3,
      "difficulty": "advanced",
      "explanation": "Conflit de méthodes default : la classe doit redéfinir la méthode pour résoudre l'ambiguïté."
    },
    {
      "topic": "Héritage",
      "question": "Que va afficher ce code ?<br><pre><code class='language-java'>class Parent {\n    static void method() { System.out.print(\"Parent\"); }\n}\nclass Child extends Parent {\n    static void method() { System.out.print(\"Child\"); }\n}\nParent p = new Child();\np.method();</code></pre>",
      "options": [
        "<code>Parent</code>",
        "<code>Child</code>",
        "<code>Compilation error</code>",
        "<code>Runtime error</code>"
      ],
      "answer": 0,
      "difficulty": "advanced",
      "explanation": "Les méthodes statiques ne sont pas polymorphes. La méthode appelée dépend du type de la référence, pas de l'objet."
    },
    {
      "topic": "Interfaces",
      "question": "Depuis Java 9, que peut contenir une interface ?<br><pre><code class='language-java'>interface MyInterface {\n    void abstractMethod();\n    default void defaultMethod() { helper(); }\n    static void staticMethod() { }\n    private void helper() { }\n}</code></pre>",
      "options": [
        "Seules les méthodes abstraites et default",
        "Toutes les méthodes sauf private",
        "Toutes ces méthodes sont valides",
        "Compilation error à cause de private"
      ],
      "answer": 2,
      "difficulty": "advanced",
      "explanation": "Java 9 a introduit les méthodes private dans les interfaces pour factoriser le code des méthodes default et static."
    }
  ]
}